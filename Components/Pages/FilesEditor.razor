@using Markdig
@using Markdig.Extensions.Tables
@using Markdig.Extensions.TaskLists
@inject Services.AppStateService AppState
@inject IJSRuntime JS
@implements IDisposable

<div class="d-flex h-100">
    <!-- Left Pane: File Explorer (Collapsible) -->
    @if (!isFilePanelCollapsed)
    {
    <div class="border-end d-flex flex-column" style="width: 300px; min-width: 250px;">
        <!-- Toolbar -->
        <div class="p-2 border-bottom bg-body-tertiary d-flex gap-1">
            <button class="btn btn-sm btn-outline-secondary" @onclick="ToggleFilePanel" title="Collapse Panel">
                <i class="bi bi-chevron-left"></i>
            </button>
            <button class="btn btn-sm btn-outline-primary" @onclick="OpenFolder" title="Open Folder">
                <i class="bi bi-folder2-open"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" @onclick="RefreshFiles" title="Refresh">
                <i class="bi bi-arrow-clockwise"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" @onclick="GoUp" title="Go Up" disabled="@string.IsNullOrEmpty(currentPath)">
                <i class="bi bi-arrow-up"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" @onclick="DeleteSelected" 
                    disabled="@(selectedFile == null)" title="Delete">
                <i class="bi bi-trash"></i>
            </button>
            <div class="input-group input-group-sm flex-grow-1">
                <input type="text" class="form-control" placeholder="Search..." @bind="searchQuery" 
                       @bind:event="oninput" />
            </div>
        </div>

        <!-- File Tree -->
        <div class="flex-grow-1 overflow-auto p-2">
            @if (isLoading)
            {
                <div class="text-center py-4">
                    <div class="spinner-border spinner-border-sm"></div>
                    <span class="ms-2">Loading...</span>
                </div>
            }
            else if (fileItems.Count == 0)
            {
                <div class="text-center text-muted py-4">
                    <i class="bi bi-folder-x display-4"></i>
                    <p class="mt-2">No files found</p>
                </div>
            }
            else
            {
                <div class="file-tree">
                    @foreach (var item in FilteredItems)
                    {
                        <div class="file-tree-item @(selectedFile?.Path == item.Path ? "selected" : "")"
                             @onclick="() => SelectFile(item)"
                             @ondblclick="() => OpenFile(item)">
                            <i class="bi @(item.IsDirectory ? "bi-folder-fill text-warning" : GetFileIcon(item.Extension)) me-2"></i>
                            @item.Name
                        </div>
                    }
                </div>
            }
        </div>

        <div class="p-2 border-top bg-body-tertiary small text-truncate" title="@currentPath">
            <i class="bi bi-folder me-1"></i>@currentPath
        </div>
    </div>
    }
    else
    {
    <!-- Collapsed Panel Toggle -->
    <div class="border-end d-flex flex-column align-items-center py-2" style="width: 40px;">
        <button class="btn btn-sm btn-outline-secondary" @onclick="ToggleFilePanel" title="Expand Panel">
            <i class="bi bi-chevron-right"></i>
        </button>
    </div>
    }

    <!-- Right Pane: Markdown Editor -->
    <div class="flex-grow-1 d-flex flex-column">
        @if (selectedFile == null || selectedFile.IsDirectory)
        {
            <div class="flex-grow-1 d-flex align-items-center justify-content-center text-muted">
                <div class="text-center">
                    <i class="bi bi-file-earmark-text display-4"></i>
                    <p class="mt-2">Select a Markdown file to edit</p>
                </div>
            </div>
        }
        else
        {
            <!-- Editor Toolbar -->
            <div class="editor-toolbar d-flex align-items-center gap-2">
                <div class="btn-group btn-group-sm">
                    <button class="btn @(editorMode == "edit" ? "btn-primary" : "btn-outline-secondary")" 
                            @onclick="SetEditMode">
                        <i class="bi bi-pencil me-1"></i>Edit
                    </button>
                    <button class="btn @(editorMode == "preview" ? "btn-primary" : "btn-outline-secondary")" 
                            @onclick="SetPreviewMode">
                        <i class="bi bi-eye me-1"></i>Preview
                    </button>
                </div>

                @if (editorMode == "edit")
                {
                    <div class="vr"></div>
                    <div class="btn-group btn-group-sm">
                        <button class="btn btn-outline-secondary" @onclick="InsertBold" title="Bold">
                            <i class="bi bi-type-bold"></i>
                        </button>
                        <button class="btn btn-outline-secondary" @onclick="InsertItalic" title="Italic">
                            <i class="bi bi-type-italic"></i>
                        </button>
                        <button class="btn btn-outline-secondary" @onclick="InsertHeading" title="Heading">
                            <i class="bi bi-type-h1"></i>
                        </button>
                        <button class="btn btn-outline-secondary" @onclick="InsertList" title="List">
                            <i class="bi bi-list-ul"></i>
                        </button>
                        <button class="btn btn-outline-secondary" @onclick="InsertLink" title="Link">
                            <i class="bi bi-link-45deg"></i>
                        </button>
                        <button class="btn btn-outline-secondary" @onclick="InsertCode" title="Code">
                            <i class="bi bi-code"></i>
                        </button>
                    </div>
                }

                <div class="ms-auto d-flex align-items-center gap-2">
                    @if (hasUnsavedChanges)
                    {
                        <span class="badge bg-warning text-dark">
                            <i class="bi bi-circle-fill me-1" style="font-size: 0.5rem;"></i>Unsaved
                        </span>
                    }
                    <button class="btn btn-sm btn-outline-secondary" @onclick="ExportAsHtml" title="Export as HTML">
                        <i class="bi bi-filetype-html me-1"></i>HTML
                    </button>
                    <button class="btn btn-sm btn-primary" @onclick="SaveFile" disabled="@(!hasUnsavedChanges)">
                        <i class="bi bi-save me-1"></i>Save
                    </button>
                    <button class="btn btn-sm btn-outline-danger" @onclick="CloseFile" title="Close File">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            </div>

            <!-- Editor Content -->
            <div class="editor-content flex-grow-1">
                @if (editorMode == "edit")
                {
                    <textarea class="form-control h-100 border-0 rounded-0" 
                              style="font-family: 'Cascadia Code', 'Consolas', monospace; resize: none; font-size: 14px;"
                              @bind="editorContent"
                              @bind:event="oninput"
                              @onkeydown="HandleKeyDown"></textarea>
                }
                else
                {
                    <div class="markdown-preview p-3">
                        @((MarkupString)renderedMarkdown)
                    </div>
                }
            </div>
        }
    </div>
</div>

@code {
    private List<FileItem> fileItems = new();
    private FileItem? selectedFile;
    private string searchQuery = string.Empty;
    private bool isLoading = false;

    // Editor state - bound to AppState for persistence across tab switches
    private string currentPath
    {
        get => string.IsNullOrEmpty(AppState.EditorCurrentPath) ? AppState.DefaultOutputPath : AppState.EditorCurrentPath;
        set => AppState.EditorCurrentPath = value;
    }
    
    private string editorContent
    {
        get => AppState.EditorContent;
        set => AppState.EditorContent = value;
    }
    
    private string originalContent
    {
        get => AppState.EditorOriginalContent;
        set => AppState.EditorOriginalContent = value;
    }

    // Monaco Editor
    private BlazorMonaco.Editor.StandaloneCodeEditor? _editor = null;
    private string editorMode = "edit";
    private string renderedMarkdown = string.Empty;
    private bool hasUnsavedChanges => editorContent != originalContent;
    private bool isFilePanelCollapsed = false;

    private System.Timers.Timer? autoSaveTimer;
    private Action? _stateHandler;

    private IEnumerable<FileItem> FilteredItems => string.IsNullOrEmpty(searchQuery)
        ? fileItems
        : fileItems.Where(f => f.Name.Contains(searchQuery, StringComparison.OrdinalIgnoreCase));

    // Monaco Editor Options
    private BlazorMonaco.Editor.StandaloneEditorConstructionOptions EditorConstructionOptions(BlazorMonaco.Editor.StandaloneCodeEditor editor)
    {
        return new BlazorMonaco.Editor.StandaloneEditorConstructionOptions
        {
            Language = "markdown",
            Theme = AppState.Theme == "dark" ? "vs-dark" : "vs",
            Value = editorContent,
            AutomaticLayout = true,
            WordWrap = "on",
            Minimap = new BlazorMonaco.Editor.EditorMinimapOptions { Enabled = false },
            FontFamily = "'Cascadia Code', 'Consolas', monospace",
            FontSize = 14,
            LineNumbers = "on"
        };
    }

    private async Task EditorOnDidInit()
    {
        if (_editor != null && !string.IsNullOrEmpty(editorContent))
        {
            await _editor.SetValue(editorContent);
        }
    }

    private async Task EditorOnDidChangeContent(BlazorMonaco.Editor.ModelContentChangedEvent e)
    {
        if (_editor != null)
        {
            editorContent = await _editor.GetValue();
            await InvokeAsync(StateHasChanged);
        }
    }

    private Action<List<string>>? _dropHandler;

    protected override async Task OnInitializedAsync()
    {
        // Ensure settings are loaded first
        await AppState.InitializeAsync();

        _stateHandler = async () => await InvokeAsync(StateHasChanged);
        AppState.OnChange += _stateHandler;

        // Subscribe to file drop events for opening markdown files
        _dropHandler = HandleFilesDropped;
        MainPage.OnFilesDropped += _dropHandler;

        await LoadFiles();

        // Restore previously open file if any
        if (!string.IsNullOrEmpty(AppState.EditorOpenFilePath) && File.Exists(AppState.EditorOpenFilePath))
        {
            var fileInfo = new FileInfo(AppState.EditorOpenFilePath);
            selectedFile = new FileItem
            {
                Name = fileInfo.Name,
                Path = fileInfo.FullName,
                Extension = fileInfo.Extension,
                IsDirectory = false
            };
            
            // Content is already in AppState, just render markdown
            RenderMarkdown();
        }

        // Setup auto-save timer
        if (AppState.AutoSaveEnabled)
        {
            autoSaveTimer = new System.Timers.Timer(3000);
            autoSaveTimer.Elapsed += async (s, e) => await AutoSave();
            autoSaveTimer.AutoReset = true;
            autoSaveTimer.Start();
        }
    }

    private void HandleFilesDropped(List<string> filePaths)
    {
        // Open the first markdown file dropped
        var mdFile = filePaths.FirstOrDefault(f => 
            f.EndsWith(".md", StringComparison.OrdinalIgnoreCase));
        
        if (!string.IsNullOrEmpty(mdFile) && File.Exists(mdFile))
        {
            InvokeAsync(async () =>
            {
                // Update current path to the file's directory
                var dir = Path.GetDirectoryName(mdFile);
                if (!string.IsNullOrEmpty(dir))
                {
                    currentPath = dir;
                    await LoadFiles();
                }
                
                // Create a FileItem and select it
                var fileInfo = new FileInfo(mdFile);
                selectedFile = new FileItem
                {
                    Name = fileInfo.Name,
                    Path = fileInfo.FullName,
                    Extension = fileInfo.Extension,
                    IsDirectory = false
                };
                
                await LoadFileContent(mdFile);
            });
        }
    }

    #region File Operations

    private async Task LoadFiles()
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            await Task.Run(() =>
            {
                fileItems.Clear();

                if (!Directory.Exists(currentPath))
                {
                    Directory.CreateDirectory(currentPath);
                }

                // Get directories
                foreach (var dir in Directory.GetDirectories(currentPath))
                {
                    var info = new DirectoryInfo(dir);
                    fileItems.Add(new FileItem
                    {
                        Name = info.Name,
                        Path = info.FullName,
                        IsDirectory = true
                    });
                }

                // Get files
                foreach (var file in Directory.GetFiles(currentPath, "*.md"))
                {
                    var info = new FileInfo(file);
                    fileItems.Add(new FileItem
                    {
                        Name = info.Name,
                        Path = info.FullName,
                        Extension = info.Extension,
                        IsDirectory = false
                    });
                }

                // Sort: directories first, then by name
                fileItems = fileItems
                    .OrderByDescending(f => f.IsDirectory)
                    .ThenBy(f => f.Name)
                    .ToList();
            });
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error loading files: {ex.Message}");
        }

        isLoading = false;
        StateHasChanged();
    }

    private async Task RefreshFiles()
    {
        await LoadFiles();
    }

    private async Task OpenFolder()
    {
        try
        {
            var result = await FolderPicker.Default.PickAsync();
            if (result.IsSuccessful)
            {
                currentPath = result.Folder.Path;
                await LoadFiles();
                selectedFile = null;
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"FolderPicker error: {ex.Message}");
        }
    }

    private async Task GoUp()
    {
        if (string.IsNullOrEmpty(currentPath)) return;
        
        var parent = Directory.GetParent(currentPath);
        if (parent != null)
        {
            currentPath = parent.FullName;
            await LoadFiles();
            selectedFile = null;
        }
    }

    private async Task SelectFile(FileItem item)
    {
        if (hasUnsavedChanges)
        {
            await SaveFile();
        }

        selectedFile = item;

        if (!item.IsDirectory && item.Path.EndsWith(".md", StringComparison.OrdinalIgnoreCase))
        {
            await LoadFileContent(item.Path);
        }
    }

    private async Task OpenFile(FileItem item)
    {
        if (item.IsDirectory)
        {
            currentPath = item.Path;
            await LoadFiles();
            selectedFile = null;
        }
        else
        {
            await SelectFile(item);
        }
    }

    private async Task LoadFileContent(string path)
    {
        try
        {
            editorContent = await File.ReadAllTextAsync(path);
            originalContent = editorContent;
            
            // Store the open file path for tab switch persistence
            AppState.EditorOpenFilePath = path;
            
            // Set Monaco Editor content if editor is available
            if (_editor != null)
            {
                await _editor.SetValue(editorContent);
            }
            
            RenderMarkdown();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            editorContent = $"Error loading file: {ex.Message}";
            originalContent = editorContent;
            AppState.EditorOpenFilePath = null;
            System.Diagnostics.Debug.WriteLine($"Error loading file: {ex.Message}");
        }
    }

    private async Task SaveFile()
    {
        if (selectedFile == null || string.IsNullOrEmpty(selectedFile.Path)) return;

        try
        {
            await File.WriteAllTextAsync(selectedFile.Path, editorContent);
            originalContent = editorContent;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error saving file: {ex.Message}");
        }
    }

    private async Task AutoSave()
    {
        if (hasUnsavedChanges && AppState.AutoSaveEnabled)
        {
            await InvokeAsync(async () =>
            {
                await SaveFile();
                StateHasChanged();
            });
        }
    }

    private async Task CreateFolder()
    {
        var folderName = $"New Folder {DateTime.Now:HHmmss}";
        var path = Path.Combine(currentPath, folderName);

        try
        {
            Directory.CreateDirectory(path);
            await LoadFiles();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error creating folder: {ex.Message}");
        }
    }

    private async Task DeleteSelected()
    {
        if (selectedFile == null) return;

        try
        {
            if (selectedFile.IsDirectory)
            {
                Directory.Delete(selectedFile.Path, true);
            }
            else
            {
                File.Delete(selectedFile.Path);
            }

            selectedFile = null;
            editorContent = string.Empty;
            originalContent = string.Empty;
            await LoadFiles();
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"Error deleting: {ex.Message}");
        }
    }

    #endregion

    #region Editor

    private void SetEditMode() => editorMode = "edit";
    private void SetPreviewMode() 
    { 
        editorMode = "preview"; 
        RenderMarkdown();
    }

    private void InsertBold() => InsertMarkdown("**", "**");
    private void InsertItalic() => InsertMarkdown("*", "*");
    private void InsertHeading() => InsertMarkdown("# ", "");
    private void InsertList() => InsertMarkdown("- ", "");
    private void InsertLink() => InsertMarkdown("[", "](url)");
    private void InsertCode() => InsertMarkdown("`", "`");

    private void InsertMarkdown(string prefix, string suffix)
    {
        editorContent = prefix + editorContent + suffix;
        StateHasChanged();
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.CtrlKey && e.Key == "s")
        {
            _ = SaveFile();
        }
    }

    private void RenderMarkdown()
    {
        try
        {
            // Enable extensions including tables, task lists, auto-links, etc.
            var pipeline = new Markdig.MarkdownPipelineBuilder()
                .UsePipeTables()
                .UseTaskLists()
                .UseAutoLinks()
                .UseEmphasisExtras()
                .Build();
            var html = Markdig.Markdown.ToHtml(editorContent, pipeline);
            
            // Convert relative image paths to base64 data URIs for WebView rendering
            if (selectedFile != null && !string.IsNullOrEmpty(selectedFile.Path))
            {
                var fileDir = Path.GetDirectoryName(selectedFile.Path);
                if (!string.IsNullOrEmpty(fileDir))
                {
                    // Replace relative image paths with base64 data URIs
                    html = System.Text.RegularExpressions.Regex.Replace(
                        html,
                        @"<img\s+([^>]*)src=""([^""]+)""",
                        match =>
                        {
                            var attrs = match.Groups[1].Value;
                            var src = match.Groups[2].Value;
                            
                            // Skip if already data URI or absolute URL
                            if (src.StartsWith("http://", StringComparison.OrdinalIgnoreCase) ||
                                src.StartsWith("https://", StringComparison.OrdinalIgnoreCase) ||
                                src.StartsWith("data:", StringComparison.OrdinalIgnoreCase))
                            {
                                return match.Value;
                            }
                            
                            try
                            {
                                // Convert relative path to absolute and read as base64
                                var absolutePath = Path.GetFullPath(Path.Combine(fileDir, src));
                                if (File.Exists(absolutePath))
                                {
                                    var bytes = File.ReadAllBytes(absolutePath);
                                    var base64 = System.Convert.ToBase64String(bytes);
                                    var ext = Path.GetExtension(absolutePath).ToLower();
                                    var mimeType = ext switch
                                    {
                                        ".png" => "image/png",
                                        ".jpg" or ".jpeg" => "image/jpeg",
                                        ".gif" => "image/gif",
                                        ".webp" => "image/webp",
                                        ".svg" => "image/svg+xml",
                                        _ => "image/png"
                                    };
                                    return $"<img {attrs}src=\"data:{mimeType};base64,{base64}\"";
                                }
                            }
                            catch
                            {
                                // If file read fails, keep original src
                            }
                            
                            return match.Value;
                        });
                }
            }
            
            renderedMarkdown = html;
        }
        catch
        {
            renderedMarkdown = "<p class='text-danger'>Error rendering markdown</p>";
        }
    }

    private void ToggleFilePanel()
    {
        isFilePanelCollapsed = !isFilePanelCollapsed;
    }

    private void CloseFile()
    {
        // Save if there are unsaved changes (prompt could be added later)
        if (hasUnsavedChanges)
        {
            // For now, just discard changes - could add confirmation dialog
        }
        
        selectedFile = null;
        editorContent = string.Empty;
        originalContent = string.Empty;
        renderedMarkdown = string.Empty;
        AppState.EditorOpenFilePath = null;
    }

    private async Task ExportAsHtml()
    {
        if (selectedFile == null) return;
        
        try
        {
            // Build HTML with styling
            var pipeline = new Markdig.MarkdownPipelineBuilder()
                .UsePipeTables()
                .UseTaskLists()
                .UseAutoLinks()
                .UseEmphasisExtras()
                .Build();
            var htmlBody = Markdig.Markdown.ToHtml(editorContent, pipeline);
            
            var htmlContent = $@"<!DOCTYPE html>
<html lang=""ja"">
<head>
    <meta charset=""UTF-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
    <title>{Path.GetFileNameWithoutExtension(selectedFile.Name)}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 2rem; }}
        h1, h2, h3 {{ color: #333; }}
        code {{ background: #f4f4f4; padding: 0.2em 0.4em; border-radius: 3px; font-family: 'Consolas', monospace; }}
        pre {{ background: #f4f4f4; padding: 1rem; border-radius: 5px; overflow-x: auto; }}
        pre code {{ background: none; padding: 0; }}
        table {{ border-collapse: collapse; width: 100%; margin: 1rem 0; }}
        th, td {{ border: 1px solid #ddd; padding: 0.5rem; text-align: left; }}
        th {{ background: #f0f0f0; font-weight: 600; }}
        blockquote {{ border-left: 4px solid #ddd; margin: 1rem 0; padding-left: 1rem; color: #666; }}
        img {{ max-width: 100%; height: auto; }}
    </style>
</head>
<body>
{htmlBody}
</body>
</html>";
            
            // Save to same location with .html extension
            var htmlPath = Path.ChangeExtension(selectedFile.Path, ".html");
            await File.WriteAllTextAsync(htmlPath, htmlContent);
            
            AppState.SetStatus($"Exported to {Path.GetFileName(htmlPath)}");
        }
        catch (Exception ex)
        {
            AppState.SetStatus($"Export failed: {ex.Message}");
        }
    }


    private string GetFileIcon(string extension) => extension?.ToLower() switch
    {
        ".md" => "bi-file-earmark-text text-primary",
        ".txt" => "bi-file-earmark-text",
        ".pdf" => "bi-file-earmark-pdf text-danger",
        ".jpg" or ".jpeg" or ".png" or ".gif" => "bi-file-earmark-image",
        _ => "bi-file-earmark"
    };

    #endregion

    public void Dispose()
    {
        if (_stateHandler != null)
        {
            AppState.OnChange -= _stateHandler;
        }
        if (_dropHandler != null)
        {
            MainPage.OnFilesDropped -= _dropHandler;
        }
        autoSaveTimer?.Dispose();
    }

    public class FileItem
    {
        public string Name { get; set; } = string.Empty;
        public string Path { get; set; } = string.Empty;
        public string Extension { get; set; } = string.Empty;
        public bool IsDirectory { get; set; }
    }
}
