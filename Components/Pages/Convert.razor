@inject Services.AppStateService AppState
@inject IJSRuntime JS
@implements IDisposable

<div class="container-fluid p-4">
    <!-- Drag & Drop Area -->
    <div class="drop-zone p-5 text-center mb-4 @(isDragOver ? "drag-over" : "")">
        <i class="bi bi-cloud-upload display-4 text-muted mb-3"></i>
        <h5 class="text-muted">Drag files or folders anywhere in the window</h5>
        <p class="text-muted small mb-2">Supported: PDF, Word, PowerPoint, Excel, HTML, XML, JSON, CSV, EPUB, ZIP</p>
        <button class="btn btn-outline-primary btn-sm" @onclick="OpenFilePicker">
            <i class="bi bi-folder2-open me-1"></i>Or click to select files
        </button>
    </div>

    <!-- Output Options -->
    <div class="settings-card mb-4">
        <div class="card-header">
            <i class="bi bi-sliders me-2"></i>Output Options
        </div>
        <div class="card-body">
            <div class="row g-3">
                <!-- Engine Selection (Checkboxes) -->
                <div class="col-md-4">
                    <label class="form-label fw-bold">Conversion Engines</label>
                    <p class="text-muted small mb-2">Select one or more engines:</p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="useMarkItDown" @bind="useMarkItDown">
                        <label class="form-check-label" for="useMarkItDown">
                            <i class="bi bi-lightning-fill text-warning me-1"></i>MarkItDown
                            <span class="text-muted small">→ _it.md</span>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="useDocling" @bind="useDocling">
                        <label class="form-check-label" for="useDocling">
                            <i class="bi bi-file-earmark-pdf text-danger me-1"></i>Docling (CPU)
                            <span class="text-muted small">→ _dl.md</span>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="useDoclingGpu" @bind="useDoclingGpu">
                        <label class="form-check-label" for="useDoclingGpu">
                            <i class="bi bi-gpu-card text-success me-1"></i>Docling (GPU)
                            <span class="text-muted small">→ _dlc.md</span>
                        </label>
                    </div>
                    @if (!HasEngineSelected)
                    {
                        <div class="text-danger small mt-1">
                            <i class="bi bi-exclamation-triangle me-1"></i>Select at least one engine
                        </div>
                    }
                </div>

                <!-- Engine Options -->
                <div class="col-md-4">
                    <label class="form-label fw-bold">Engine Options</label>
                    <p class="text-muted small mb-2">For Docling engines:</p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="enableOcr" @bind="enableOcr"
                               disabled="@(!useDocling && !useDoclingGpu)">
                        <label class="form-check-label" for="enableOcr">Enable OCR</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="includeImages" @bind="includeImages"
                               disabled="@(!useDocling && !useDoclingGpu)">
                        <label class="form-check-label" for="includeImages">Include Images</label>
                    </div>
                </div>

                <!-- Output Mode -->
                <div class="col-md-4">
                    <label class="form-label fw-bold">Output Location</label>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="outputMode" id="outputSame" 
                               checked="@useOriginalFolder" @onchange="() => useOriginalFolder = true">
                        <label class="form-check-label" for="outputSame">Same as original file</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="outputMode" id="outputCustom"
                               checked="@(!useOriginalFolder)" @onchange="() => useOriginalFolder = false">
                        <label class="form-check-label" for="outputCustom">Specific folder</label>
                    </div>
                    @if (!useOriginalFolder)
                    {
                        <div class="input-group input-group-sm mt-2">
                            <input type="text" class="form-control" @bind="outputPath" placeholder="Output folder..." />
                            <button class="btn btn-outline-secondary" type="button" @onclick="SelectOutputFolder">
                                <i class="bi bi-folder2-open"></i>
                            </button>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <!-- Action Buttons -->
    <div class="d-flex gap-2 mb-3">
        <button class="btn btn-primary" @onclick="StartConversion" 
                disabled="@(queueItems.Count == 0 || isConverting || !AppState.IsVenvActive || !HasEngineSelected)">
            @if (isConverting)
            {
                <span class="spinner-border spinner-border-sm me-1"></span>
                <span>Converting...</span>
            }
            else
            {
                <i class="bi bi-play-fill me-1"></i>
                <span>Start Selected Conversions</span>
            }
        </button>
        @if (isConverting)
        {
            <button class="btn btn-warning" @onclick="PauseConversion">
                <i class="bi bi-pause-fill me-1"></i>Pause
            </button>
            <button class="btn btn-danger" @onclick="CancelConversion">
                <i class="bi bi-x-circle me-1"></i>Cancel
            </button>
        }
        <div class="ms-auto">
            <button class="btn btn-outline-secondary" @onclick="RemoveSelected" disabled="@(SelectedCount == 0)">
                <i class="bi bi-trash me-1"></i>Remove Selected
            </button>
            <button class="btn btn-outline-secondary" @onclick="ClearAll" disabled="@(queueItems.Count == 0)">
                <i class="bi bi-x-lg me-1"></i>Clear All
            </button>
        </div>
    </div>

    <!-- Conversion Queue -->
    <div class="settings-card">
        <div class="card-header d-flex justify-content-between align-items-center">
            <span><i class="bi bi-list-ul me-2"></i>Conversion Queue</span>
            <span class="badge bg-secondary">@queueItems.Count files</span>
        </div>
        <div class="card-body p-0">
            @if (queueItems.Count == 0)
            {
                <div class="text-center text-muted py-5">
                    <i class="bi bi-inbox display-4"></i>
                    <p class="mt-2">No files in queue. Drag files anywhere in the window to add.</p>
                </div>
            }
            else
            {
                <div class="table-responsive">
                    <table class="table table-hover queue-table mb-0">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" class="form-check-input" 
                                           @bind="selectAll" @onclick="ToggleSelectAll" />
                                </th>
                                <th>Name</th>
                                <th style="width: 100px;">File Type</th>
                                <th>Path</th>
                                <th style="width: 140px;">Status</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var item in queueItems)
                            {
                                <tr>
                                    <td>
                                        <input type="checkbox" class="form-check-input" @bind="item.IsSelected" />
                                    </td>
                                    <td>
                                        <i class="bi @GetFileIcon(item.FileType) me-2"></i>
                                        @item.FileName
                                    </td>
                                    <td><span class="badge bg-light text-dark">@item.FileType</span></td>
                                    <td class="text-truncate" style="max-width: 300px;" title="@item.FilePath">
                                        @item.FilePath
                                    </td>
                                    <td>
                                        <span class="queue-item-status @GetStatusClass(item.Status)">
                                            @if (item.Status == ConversionStatus.Converting)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1"></span>
                                            }
                                            @item.Status
                                        </span>
                                    </td>
                                    <td>
                                        <button class="btn btn-sm btn-link text-danger p-0" @onclick="() => RemoveItem(item)"
                                                title="Remove">
                                            <i class="bi bi-x-lg"></i>
                                        </button>
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }
        </div>
    </div>
</div>

@code {
    private List<QueueItem> queueItems = new();
    private bool isDragOver = false;
    private bool isConverting = false;
    private bool selectAll = false;

    // Engine options (checkboxes)
    private bool useMarkItDown = true;
    private bool useDocling = false;
    private bool useDoclingGpu = false;
    
    // Engine-specific options
    private bool enableOcr = false;
    private bool includeImages = false;
    
    // Output options
    private bool useOriginalFolder = true;
    private string outputPath = string.Empty;

    private CancellationTokenSource? cancellationTokenSource;
    private Action? _stateHandler;
    private Action<List<string>>? _dropHandler;

    private int SelectedCount => queueItems.Count(x => x.IsSelected);
    private bool HasEngineSelected => useMarkItDown || useDocling || useDoclingGpu;

    // Supported file extensions
    private static readonly HashSet<string> SupportedExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".pdf", ".docx", ".doc", ".pptx", ".ppt", ".xlsx", ".xls",
        ".html", ".htm", ".xml", ".json", ".csv", ".epub", ".zip"
    };

    protected override void OnInitialized()
    {
        // Subscribe to AppState changes
        _stateHandler = async () => await InvokeAsync(StateHasChanged);
        AppState.OnChange += _stateHandler;

        // Subscribe to MAUI native drop events
        _dropHandler = HandleFilesDropped;
        MainPage.OnFilesDropped += _dropHandler;

        // Load saved settings
        outputPath = AppState.DefaultOutputPath;
        useOriginalFolder = AppState.UseOriginalFolderForOutput;
    }

    #region File Drop Handling

    private void HandleFilesDropped(List<string> filePaths)
    {
        foreach (var path in filePaths)
        {
            AddFileToQueue(path);
        }
        InvokeAsync(StateHasChanged);
    }

    private void AddFileToQueue(string path)
    {
        // Check if it's a directory
        if (Directory.Exists(path))
        {
            // Add all supported files from directory
            foreach (var file in Directory.GetFiles(path, "*.*", SearchOption.TopDirectoryOnly))
            {
                AddSingleFile(file);
            }
        }
        else if (File.Exists(path))
        {
            AddSingleFile(path);
        }
    }

    private void AddSingleFile(string filePath)
    {
        var ext = Path.GetExtension(filePath);
        if (!SupportedExtensions.Contains(ext))
            return;

        // Check for duplicates
        if (queueItems.Any(q => q.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase)))
            return;

        queueItems.Add(new QueueItem
        {
            FileName = Path.GetFileName(filePath),
            FilePath = filePath,
            FileType = ext.TrimStart('.').ToUpperInvariant(),
            IsSelected = true,
            Status = ConversionStatus.Queued
        });
    }

    private async Task OpenFilePicker()
    {
        try
        {
            var options = new PickOptions
            {
                PickerTitle = "Select files to convert",
                FileTypes = new FilePickerFileType(new Dictionary<DevicePlatform, IEnumerable<string>>
                {
                    { DevicePlatform.WinUI, SupportedExtensions.ToArray() }
                })
            };

            var files = await FilePicker.Default.PickMultipleAsync(options);
            if (files != null)
            {
                foreach (var file in files)
                {
                    AddSingleFile(file.FullPath);
                }
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"FilePicker error: {ex.Message}");
        }
    }

    private async Task SelectOutputFolder()
    {
        try
        {
            var result = await FolderPicker.Default.PickAsync();
            if (result.IsSuccessful)
            {
                outputPath = result.Folder.Path;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"FolderPicker error: {ex.Message}");
        }
    }

    #endregion

    #region Queue Management

    private void ToggleSelectAll()
    {
        var newValue = !selectAll;
        foreach (var item in queueItems)
        {
            item.IsSelected = newValue;
        }
    }

    private void RemoveItem(QueueItem item)
    {
        queueItems.Remove(item);
        StateHasChanged();
    }

    private void RemoveSelected()
    {
        queueItems.RemoveAll(x => x.IsSelected);
        StateHasChanged();
    }

    private void ClearAll()
    {
        queueItems.Clear();
        StateHasChanged();
    }

    #endregion

    #region Conversion

    private async Task StartConversion()
    {
        var selectedItems = queueItems.Where(x => x.IsSelected && x.Status == ConversionStatus.Queued).ToList();
        if (selectedItems.Count == 0 || !HasEngineSelected) return;

        isConverting = true;
        cancellationTokenSource = new CancellationTokenSource();
        AppState.SetStatus("Converting files...", true);

        try
        {
            foreach (var item in selectedItems)
            {
                if (cancellationTokenSource.Token.IsCancellationRequested) break;

                item.Status = ConversionStatus.Converting;
                StateHasChanged();

                // TODO: Replace with actual conversion logic using ConversionService
                // For now, simulate conversion
                await Task.Delay(2000, cancellationTokenSource.Token);

                item.Status = ConversionStatus.Completed;
                StateHasChanged();
            }
        }
        catch (OperationCanceledException)
        {
            // Cancelled
        }
        finally
        {
            isConverting = false;
            cancellationTokenSource?.Dispose();
            cancellationTokenSource = null;
            AppState.SetStatus("Ready");
            StateHasChanged();
        }
    }

    private void PauseConversion()
    {
        cancellationTokenSource?.Cancel();
    }

    private void CancelConversion()
    {
        cancellationTokenSource?.Cancel();
        
        // Reset converting items to queued
        foreach (var item in queueItems.Where(x => x.Status == ConversionStatus.Converting))
        {
            item.Status = ConversionStatus.Queued;
        }
    }

    #endregion

    #region Helpers

    private string GetFileIcon(string fileType) => fileType.ToUpper() switch
    {
        "PDF" => "bi-file-earmark-pdf text-danger",
        "DOCX" or "DOC" => "bi-file-earmark-word text-primary",
        "XLSX" or "XLS" => "bi-file-earmark-excel text-success",
        "PPTX" or "PPT" => "bi-file-earmark-ppt text-warning",
        "HTML" or "HTM" => "bi-file-earmark-code",
        "XML" => "bi-file-earmark-code",
        "JSON" => "bi-file-earmark-code",
        "CSV" => "bi-file-earmark-spreadsheet",
        "EPUB" => "bi-book",
        "ZIP" => "bi-file-earmark-zip",
        _ => "bi-file-earmark"
    };

    private string GetStatusClass(ConversionStatus status) => status switch
    {
        ConversionStatus.Queued => "status-queued",
        ConversionStatus.Converting => "status-converting",
        ConversionStatus.Completed => "status-completed",
        ConversionStatus.Failed => "status-failed",
        ConversionStatus.Unsupported => "status-unsupported",
        _ => ""
    };

    #endregion

    public void Dispose()
    {
        if (_stateHandler != null)
        {
            AppState.OnChange -= _stateHandler;
        }
        if (_dropHandler != null)
        {
            MainPage.OnFilesDropped -= _dropHandler;
        }
        cancellationTokenSource?.Dispose();
    }

    public class QueueItem
    {
        public string FileName { get; set; } = string.Empty;
        public string FilePath { get; set; } = string.Empty;
        public string FileType { get; set; } = string.Empty;
        public bool IsSelected { get; set; } = true;
        public ConversionStatus Status { get; set; } = ConversionStatus.Queued;
        public string? ErrorMessage { get; set; }
    }

    public enum ConversionStatus
    {
        Queued,
        Converting,
        Completed,
        Failed,
        Unsupported
    }
}
