@using MarkBridge.Services
@inject Services.AppStateService AppState
@inject Services.ConversionService ConversionSvc
@inject IJSRuntime JS
@implements IDisposable

<div class="container-fluid p-4">
    <!-- Drag & Drop Area -->
    <div class="drop-zone p-5 text-center mb-4 @(isDragOver ? "drag-over" : "")">
        <i class="bi bi-cloud-upload display-4 text-muted mb-3"></i>
        <h5 class="text-muted">Drag files or folders anywhere in the window</h5>
        <p class="text-muted small mb-2">Supported: PDF, Word, PowerPoint, Excel, HTML, XML, JSON, CSV, EPUB, ZIP</p>
        <button class="btn btn-outline-primary btn-sm" @onclick="OpenFilePicker">
            <i class="bi bi-folder2-open me-1"></i>Or click to select files
        </button>
    </div>

    <!-- Output Options -->
    <div class="settings-card mb-4">
        <div class="card-header">
            <i class="bi bi-sliders me-2"></i>Output Options
        </div>
        <div class="card-body">
            <div class="row g-3">
                <!-- Engine Selection (Checkboxes) -->
                <div class="col-md-4">
                    <label class="form-label fw-bold">Conversion Engines</label>
                    <p class="text-muted small mb-2">Select one or more engines:</p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="useMarkItDown" @bind="useMarkItDown">
                        <label class="form-check-label" for="useMarkItDown">
                            <i class="bi bi-lightning-fill text-warning me-1"></i>MarkItDown
                            <span class="text-muted small">→ _it.md</span>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="useDocling" @bind="useDocling">
                        <label class="form-check-label" for="useDocling">
                            <i class="bi bi-file-earmark-pdf text-danger me-1"></i>Docling (CPU)
                            <span class="text-muted small">→ _dl.md</span>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="useDoclingGpu" @bind="useDoclingGpu">
                        <label class="form-check-label" for="useDoclingGpu">
                            <i class="bi bi-gpu-card text-success me-1"></i>Docling (GPU)
                            <span class="text-muted small">→ _dlc.md</span>
                        </label>
                    </div>
                    @if (!HasEngineSelected)
                    {
                        <div class="text-danger small mt-1">
                            <i class="bi bi-exclamation-triangle me-1"></i>Select at least one engine
                        </div>
                    }
                </div>

                <!-- Engine Options -->
                <div class="col-md-4">
                    <label class="form-label fw-bold">Engine Options</label>
                    <p class="text-muted small mb-2">For Docling engines:</p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="enableOcr" @bind="enableOcr"
                               disabled="@(!useDocling && !useDoclingGpu)">
                        <label class="form-check-label" for="enableOcr">Enable OCR</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="includeImages" @bind="includeImages"
                               disabled="@(!useDocling && !useDoclingGpu)">
                        <label class="form-check-label" for="includeImages">Include Images</label>
                    </div>
                </div>

                <!-- Output Mode -->
                <div class="col-md-4">
                    <label class="form-label fw-bold">Output Location</label>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="outputMode" id="outputSame" 
                               checked="@useOriginalFolder" @onchange="() => useOriginalFolder = true">
                        <label class="form-check-label" for="outputSame">Same as original file</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="outputMode" id="outputCustom"
                               checked="@(!useOriginalFolder)" @onchange="() => useOriginalFolder = false">
                        <label class="form-check-label" for="outputCustom">Specific folder</label>
                    </div>
                    @if (!useOriginalFolder)
                    {
                        <div class="input-group input-group-sm mt-2">
                            <input type="text" class="form-control" @bind="outputPath" placeholder="Output folder..." />
                            <button class="btn btn-outline-secondary" type="button" @onclick="SelectOutputFolder">
                                <i class="bi bi-folder2-open"></i>
                            </button>
                        </div>
                    }
                </div>
            </div>
        </div>
    </div>

    <!-- Action Buttons -->
    <div class="d-flex gap-2 mb-3">
        <button class="btn btn-primary" @onclick="StartConversion" 
                disabled="@(queueItems.Count == 0 || isConverting || !AppState.IsVenvActive || !HasEngineSelected)">
            @if (isConverting)
            {
                <span class="spinner-border spinner-border-sm me-1"></span>
                <span>Converting...</span>
            }
            else
            {
                <i class="bi bi-play-fill me-1"></i>
                <span>Start Selected Conversions</span>
            }
        </button>
        @if (isConverting)
        {
            <button class="btn btn-warning" @onclick="PauseConversion">
                <i class="bi bi-pause-fill me-1"></i>Pause
            </button>
            <button class="btn btn-danger" @onclick="CancelConversion">
                <i class="bi bi-x-circle me-1"></i>Cancel
            </button>
        }
        <div class="ms-auto">
            <button class="btn btn-outline-secondary" @onclick="RemoveSelected" disabled="@(SelectedCount == 0)">
                <i class="bi bi-trash me-1"></i>Remove Selected
            </button>
            <button class="btn btn-outline-secondary" @onclick="ClearAll" disabled="@(queueItems.Count == 0)">
                <i class="bi bi-x-lg me-1"></i>Clear All
            </button>
        </div>
    </div>

    <!-- Conversion Queue -->
    <div class="settings-card">
        <div class="card-header d-flex justify-content-between align-items-center">
            <span><i class="bi bi-list-ul me-2"></i>Conversion Queue</span>
            <span class="badge bg-secondary">@queueItems.Count files</span>
        </div>
        <div class="card-body p-0">
            @if (queueItems.Count == 0)
            {
                <div class="text-center text-muted py-5">
                    <i class="bi bi-inbox display-4"></i>
                    <p class="mt-2">No files in queue. Drag files anywhere in the window to add.</p>
                </div>
            }
            else
            {
                <div class="table-responsive">
                    <table class="table table-hover queue-table mb-0">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" class="form-check-input" 
                                           @bind="selectAll" @onclick="ToggleSelectAll" />
                                </th>
                                <th>Name</th>
                                <th style="width: 120px;">Engine</th>
                                <th style="width: 100px;">File Type</th>
                                <th>Path</th>
                                <th style="width: 140px;">Status</th>
                                <th style="width: 50px;"></th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var item in queueItems)
                            {
                                <tr>
                                    <td>
                                        <input type="checkbox" class="form-check-input" @bind="item.IsSelected" />
                                    </td>
                                    <td>
                                        <i class="bi @GetFileIcon(item.FileType) me-2"></i>
                                        @item.FileName
                                        <span class="text-muted small">→ @item.OutputSuffix</span>
                                    </td>
                                    <td>
                                        <span class="badge @GetEngineBadgeClass(item.Engine)">@item.EngineName</span>
                                    </td>
                                    <td><span class="badge bg-light text-dark">@item.FileType</span></td>
                                    <td class="text-truncate" style="max-width: 300px;" title="@item.FilePath">
                                        @item.FilePath
                                    </td>
                                    <td>
                                        <span class="queue-item-status @GetStatusClass(item.Status)" 
                                              title="@(item.Status == ConversionStatus.Failed ? item.ErrorMessage : "")">
                                            @if (item.Status == ConversionStatus.Converting)
                                            {
                                                <span class="spinner-border spinner-border-sm me-1"></span>
                                            }
                                            @item.Status
                                            @if (item.Status == ConversionStatus.Completed && item.ElapsedTime.HasValue)
                                            {
                                                <span class="text-muted ms-1 small">(@item.ElapsedTimeText)</span>
                                            }
                                        </span>
                                    </td>
                                    <td>
                                        <button class="btn btn-sm btn-link text-danger p-0" @onclick="() => RemoveItem(item)"
                                                title="Remove">
                                            <i class="bi bi-x-lg"></i>
                                        </button>
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
                
                @* Error Messages Display *@
                @if (queueItems.Any(x => x.Status == ConversionStatus.Failed && !string.IsNullOrEmpty(x.ErrorMessage)))
                {
                    <div class="mt-3">
                        <h6 class="text-danger"><i class="bi bi-exclamation-triangle me-2"></i>Conversion Errors</h6>
                        <div class="bg-dark text-light p-3 rounded" style="max-height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.85rem;">
                            @foreach (var item in queueItems.Where(x => x.Status == ConversionStatus.Failed && !string.IsNullOrEmpty(x.ErrorMessage)))
                            {
                                <div class="mb-2">
                                    <strong>@item.FileName:</strong><br />
                                    <span class="text-warning">@item.ErrorMessage</span>
                                </div>
                            }
                        </div>
                    </div>
                }
            }
        </div>
    </div>
</div>

@code {
    // Queue items - now stored in AppState for persistence across tab switches
    private List<QueueItem> queueItems => AppState.QueueItems;
    
    private bool isDragOver = false;
    private bool isConverting = false;
    private bool selectAll = false;

    // Engine options - now bound to AppState for persistence
    private bool useMarkItDown
    {
        get => AppState.UseMarkItDown;
        set => AppState.UseMarkItDown = value;
    }
    private bool useDocling
    {
        get => AppState.UseDocling;
        set => AppState.UseDocling = value;
    }
    private bool useDoclingGpu
    {
        get => AppState.UseDoclingGpu;
        set => AppState.UseDoclingGpu = value;
    }
    
    // Engine-specific options - now bound to AppState for persistence
    private bool enableOcr
    {
        get => AppState.EnableOcr;
        set => AppState.EnableOcr = value;
    }
    private bool includeImages
    {
        get => AppState.IncludeImages;
        set => AppState.IncludeImages = value;
    }
    
    // Output options - now bound to AppState for persistence
    private bool useOriginalFolder
    {
        get => AppState.UseOriginalFolderForOutput;
        set => AppState.UseOriginalFolderForOutput = value;
    }
    private string outputPath
    {
        get => AppState.DefaultOutputPath;
        set => AppState.DefaultOutputPath = value;
    }

    private CancellationTokenSource? cancellationTokenSource;
    private Action? _stateHandler;
    private Action<List<string>>? _dropHandler;

    private int SelectedCount => queueItems.Count(x => x.IsSelected);
    private bool HasEngineSelected => useMarkItDown || useDocling || useDoclingGpu;

    // Supported file extensions
    private static readonly HashSet<string> SupportedExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".pdf", ".docx", ".doc", ".pptx", ".ppt", ".xlsx", ".xls",
        ".html", ".htm", ".xml", ".json", ".csv", ".epub", ".zip"
    };

    protected override void OnInitialized()
    {
        // Subscribe to AppState changes
        _stateHandler = async () => await InvokeAsync(StateHasChanged);
        AppState.OnChange += _stateHandler;

        // Subscribe to MAUI native drop events
        _dropHandler = HandleFilesDropped;
        MainPage.OnFilesDropped += _dropHandler;
    }

    #region File Drop Handling

    private void HandleFilesDropped(List<string> filePaths)
    {
        foreach (var path in filePaths)
        {
            AddFileToQueue(path);
        }
        InvokeAsync(StateHasChanged);
    }

    private void AddFileToQueue(string path)
    {
        // Check if it's a directory
        if (Directory.Exists(path))
        {
            // Add all supported files from directory
            foreach (var file in Directory.GetFiles(path, "*.*", SearchOption.TopDirectoryOnly))
            {
                AddSingleFile(file);
            }
        }
        else if (File.Exists(path))
        {
            AddSingleFile(path);
        }
    }

    private void AddSingleFile(string filePath)
    {
        var ext = Path.GetExtension(filePath);
        if (!SupportedExtensions.Contains(ext))
            return;

        // Get currently selected engines
        var engines = GetSelectedEngines();
        if (engines.Count == 0)
        {
            // If no engine selected, add with null engine (will use engine selection at conversion time)
            if (!queueItems.Any(q => q.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase) && q.Engine == null))
            {
                queueItems.Add(new QueueItem
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    FileType = ext.TrimStart('.').ToUpperInvariant(),
                    IsSelected = true,
                    Status = ConversionStatus.Queued,
                    Engine = null
                });
            }
        }
        else
        {
            // Create separate queue items for each selected engine
            foreach (var engine in engines)
            {
                // Check for duplicates (same file + same engine)
                if (queueItems.Any(q => q.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase) && q.Engine == engine))
                    continue;

                queueItems.Add(new QueueItem
                {
                    FileName = Path.GetFileName(filePath),
                    FilePath = filePath,
                    FileType = ext.TrimStart('.').ToUpperInvariant(),
                    IsSelected = true,
                    Status = ConversionStatus.Queued,
                    Engine = engine
                });
            }
        }
    }

    private List<MarkBridge.Services.ConversionEngine> GetSelectedEngines()
    {
        var engines = new List<MarkBridge.Services.ConversionEngine>();
        if (useMarkItDown) engines.Add(MarkBridge.Services.ConversionEngine.MarkItDown);
        if (useDocling) engines.Add(MarkBridge.Services.ConversionEngine.Docling);
        if (useDoclingGpu) engines.Add(MarkBridge.Services.ConversionEngine.DoclingGpu);
        return engines;
    }

    private async Task OpenFilePicker()
    {
        try
        {
            var options = new PickOptions
            {
                PickerTitle = "Select files to convert",
                FileTypes = new FilePickerFileType(new Dictionary<DevicePlatform, IEnumerable<string>>
                {
                    { DevicePlatform.WinUI, SupportedExtensions.ToArray() }
                })
            };

            var files = await FilePicker.Default.PickMultipleAsync(options);
            if (files != null)
            {
                foreach (var file in files)
                {
                    AddSingleFile(file.FullPath);
                }
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"FilePicker error: {ex.Message}");
        }
    }

    private async Task SelectOutputFolder()
    {
        try
        {
            var result = await FolderPicker.Default.PickAsync();
            if (result.IsSuccessful)
            {
                outputPath = result.Folder.Path;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"FolderPicker error: {ex.Message}");
        }
    }

    #endregion

    #region Queue Management

    private void ToggleSelectAll()
    {
        var newValue = !selectAll;
        foreach (var item in queueItems)
        {
            item.IsSelected = newValue;
        }
    }

    private void RemoveItem(QueueItem item)
    {
        queueItems.Remove(item);
        StateHasChanged();
    }

    private void RemoveSelected()
    {
        queueItems.RemoveAll(x => x.IsSelected);
        StateHasChanged();
    }

    private void ClearAll()
    {
        queueItems.Clear();
        StateHasChanged();
    }

    #endregion

    #region Conversion

    private async Task StartConversion()
    {
        var selectedItems = queueItems.Where(x => x.IsSelected && x.Status == ConversionStatus.Queued).ToList();
        if (selectedItems.Count == 0 || !HasEngineSelected) return;

        isConverting = true;
        cancellationTokenSource = new CancellationTokenSource();
        AppState.SetStatus("Converting files...", true);

        var targetOutputPath = useOriginalFolder 
            ? null 
            : (string.IsNullOrEmpty(outputPath) ? AppState.DefaultOutputPath : outputPath);

        var options = new MarkBridge.Services.ConversionOptions
        {
            EnableOcr = enableOcr,
            IncludeImages = includeImages
        };

        try
        {
            // Process items with their assigned engines (can be parallelized in future)
            var tasks = new List<Task>();
            var semaphore = new SemaphoreSlim(AppState.MaxConcurrency);
            
            foreach (var item in selectedItems)
            {
                if (cancellationTokenSource.Token.IsCancellationRequested) break;

                // Get the engine for this item (use assigned engine)
                var engine = item.Engine;
                if (engine == null)
                {
                    // If no engine assigned, skip or use first selected engine
                    var selectedEngines = GetSelectedEngines();
                    if (selectedEngines.Count == 0)
                    {
                        item.Status = ConversionStatus.Failed;
                        item.ErrorMessage = "No engine selected";
                        continue;
                    }
                    engine = selectedEngines[0];
                }

                var task = Task.Run(async () =>
                {
                    await semaphore.WaitAsync(cancellationTokenSource.Token);
                    try
                    {
                        item.Status = ConversionStatus.Converting;
                        await InvokeAsync(StateHasChanged);

                        var itemOutputPath = useOriginalFolder 
                            ? Path.GetDirectoryName(item.FilePath) ?? ""
                            : targetOutputPath ?? "";

                        var result = await ConversionSvc.ConvertFileAsync(
                            item.FilePath,
                            itemOutputPath,
                            engine.Value,
                            options,
                            cancellationTokenSource.Token,
                            msg => System.Diagnostics.Debug.WriteLine(msg));

                        if (result.Success)
                        {
                            item.Status = ConversionStatus.Completed;
                            item.ElapsedTime = result.ElapsedTime;
                        }
                        else
                        {
                            item.ErrorMessage = result.ErrorMessage;
                            item.Status = ConversionStatus.Failed;
                            item.ElapsedTime = result.ElapsedTime;
                            System.Diagnostics.Debug.WriteLine($"Conversion failed: {result.ErrorMessage}");
                        }
                        await InvokeAsync(StateHasChanged);
                    }
                    finally
                    {
                        semaphore.Release();
                    }
                }, cancellationTokenSource.Token);
                
                tasks.Add(task);
            }
            
            await Task.WhenAll(tasks);
        }
        catch (OperationCanceledException)
        {
            // Cancelled
        }
        finally
        {
            isConverting = false;
            cancellationTokenSource?.Dispose();
            cancellationTokenSource = null;
            AppState.SetStatus("Ready");
            StateHasChanged();
        }
    }

    private void PauseConversion()
    {
        cancellationTokenSource?.Cancel();
    }

    private void CancelConversion()
    {
        cancellationTokenSource?.Cancel();
        
        // Reset converting items to queued
        foreach (var item in queueItems.Where(x => x.Status == ConversionStatus.Converting))
        {
            item.Status = ConversionStatus.Queued;
        }
    }

    #endregion

    #region Helpers

    private string GetFileIcon(string fileType) => fileType.ToUpper() switch
    {
        "PDF" => "bi-file-earmark-pdf text-danger",
        "DOCX" or "DOC" => "bi-file-earmark-word text-primary",
        "XLSX" or "XLS" => "bi-file-earmark-excel text-success",
        "PPTX" or "PPT" => "bi-file-earmark-ppt text-warning",
        "HTML" or "HTM" => "bi-file-earmark-code",
        "XML" => "bi-file-earmark-code",
        "JSON" => "bi-file-earmark-code",
        "CSV" => "bi-file-earmark-spreadsheet",
        "EPUB" => "bi-book",
        "ZIP" => "bi-file-earmark-zip",
        _ => "bi-file-earmark"
    };

    private string GetStatusClass(ConversionStatus status) => status switch
    {
        ConversionStatus.Queued => "status-queued",
        ConversionStatus.Converting => "status-converting",
        ConversionStatus.Completed => "status-completed",
        ConversionStatus.Failed => "status-failed",
        ConversionStatus.Unsupported => "status-unsupported",
        _ => ""
    };

    private string GetEngineBadgeClass(MarkBridge.Services.ConversionEngine? engine) => engine switch
    {
        MarkBridge.Services.ConversionEngine.MarkItDown => "bg-warning text-dark",
        MarkBridge.Services.ConversionEngine.Docling => "bg-danger",
        MarkBridge.Services.ConversionEngine.DoclingGpu => "bg-success",
        _ => "bg-secondary"
    };

    #endregion

    public void Dispose()
    {
        if (_stateHandler != null)
        {
            AppState.OnChange -= _stateHandler;
        }
        if (_dropHandler != null)
        {
            MainPage.OnFilesDropped -= _dropHandler;
        }
        cancellationTokenSource?.Dispose();
    }

    // QueueItem and ConversionStatus are now defined in AppStateService.cs
}

